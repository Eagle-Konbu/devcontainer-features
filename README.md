# Dev Container Features

This repository provides custom [dev container Features](https://containers.dev/implementors/features/) following the [dev container Feature distribution specification](https://containers.dev/implementors/features-distribution/).

## Available Features

### `goreg`

Installs [goreg](https://github.com/magicdrive/goreg), a Go import formatting tool that organizes imports into distinct groups.

**Source**: [magicdrive/goreg](https://github.com/magicdrive/goreg)

```jsonc
{
    "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
    "features": {
        "ghcr.io/Eagle-Konbu/devcontainer-features/goreg:1": {
            "version": "latest"
        }
    }
}
```

Available options:
- `version`: Version of goreg to install. Use `latest` for the most recent version, or specify a version like `1.2.10` (default: `latest`)

Usage:

```bash
$ goreg --help
```

## Repo and Feature Structure

Similar to the [`devcontainers/features`](https://github.com/devcontainers/features) repo, this repository has a `src` folder.  Each Feature has its own sub-folder, containing at least a `devcontainer-feature.json` and an entrypoint script `install.sh`. 

```
├── src
│   ├── goreg
│   │   ├── devcontainer-feature.json
│   │   └── install.sh
|   ├── ...
│   │   ├── devcontainer-feature.json
│   │   └── install.sh
...
```

An [implementing tool](https://containers.dev/supporting#tools) will composite [the documented dev container properties](https://containers.dev/implementors/features/#devcontainer-feature-json-properties) from the feature's `devcontainer-feature.json` file, and execute in the `install.sh` entrypoint script in the container during build time.  Implementing tools are also free to process attributes under the `customizations` property as desired.

### Options

All available options for a Feature should be declared in the `devcontainer-feature.json`.  The syntax for the `options` property can be found in the [devcontainer Feature json properties reference](https://containers.dev/implementors/features/#devcontainer-feature-json-properties).

For example, the `goreg` feature provides a version option. Options are exported as Feature-scoped environment variables.  The option name is capitalized and sanitized according to [option resolution](https://containers.dev/implementors/features/#option-resolution).

## Testing

This repository follows the devcontainer CLI's three-tier testing structure:

### Test Structure Overview

1. **Autogenerated Tests** (`test/<feature>/test.sh`)
   - Basic smoke tests that verify minimal functionality
   - Runs with default options (no custom options specified)
   - Should only check: command availability, basic execution (e.g., `--help`)
   - Example: Verify `goreg` is installed and can display help

2. **Scenario Tests** (`test/<feature>/scenarios.json` + scenario scripts)
   - Tests for different option combinations and edge cases
   - Each scenario defines a specific feature configuration
   - Use separate test scripts per scenario (e.g., `default.sh`, `version_latest.sh`, `version_specific.sh`)
   - Example scenarios:
     - `default`: No options specified
     - `version_latest`: Install latest version
     - `version_specific`: Install a specific version (e.g., 1.2.10)

3. **Global Tests** (`test/_global/scenarios.json` + global scripts)
   - Integration tests combining multiple features
   - Tests for common policies (e.g., non-root user compatibility, PATH configuration)
   - Validates cross-feature compatibility and shared requirements
   - Example: Test `goreg` works correctly with the Go feature installed

### Running Tests Locally

```bash
# Install devcontainer CLI
npm install -g @devcontainers/cli

# Run all tests
devcontainer features test .

# Run only autogenerated tests
devcontainer features test -f goreg --skip-scenarios .

# Run only scenario tests
devcontainer features test -f goreg --skip-autogenerated .

# Run only global tests
devcontainer features test --global-scenarios-only .
```

### Adding Tests for New Features

When adding a new feature, follow this checklist:

1. **Create `test/<feature>/test.sh`**
   - Add basic smoke test (command availability, help output)
   - Keep it minimal - just verify installation succeeded

2. **Create `test/<feature>/scenarios.json`**
   - Add at least 2-3 scenarios:
     - `default`: No options
     - Options variations: Test key option combinations
   - Create corresponding test scripts (e.g., `default.sh`, `option_x.sh`)

3. **Update `test/_global/scenarios.json`** (if applicable)
   - Add integration scenarios if the feature:
     - Requires other features (e.g., `goreg` requires Go)
     - Should work with common feature combinations
     - Has shared policy requirements

4. **Update CI matrix**
   - Add the new feature to `.github/workflows/test.yaml` matrix

5. **Verify all test tiers pass**
   ```bash
   devcontainer features test .
   ```

## Distributing Features

### Versioning

Features are individually versioned by the `version` attribute in a Feature's `devcontainer-feature.json`.  Features are versioned according to the semver specification. More details can be found in [the dev container Feature specification](https://containers.dev/implementors/features/#versioning).

### Publishing

> NOTE: The Distribution spec can be [found here](https://containers.dev/implementors/features-distribution/).  
>
> While any registry [implementing the OCI Distribution spec](https://github.com/opencontainers/distribution-spec) can be used, this template will leverage GHCR (GitHub Container Registry) as the backing registry.

Features are meant to be easily sharable units of dev container configuration and installation code.  

This repo contains a **GitHub Action** [workflow](.github/workflows/release.yaml) that will publish each Feature to GHCR. 

*Allow GitHub Actions to create and approve pull requests* should be enabled in the repository's `Settings > Actions > General > Workflow permissions` for auto generation of `src/<feature>/README.md` per Feature (which merges any existing `src/<feature>/NOTES.md`).

By default, each Feature will be prefixed with the `<owner/<repo>` namespace.  For example, the Features in this repository can be referenced in a `devcontainer.json` with:

```
ghcr.io/Eagle-Konbu/devcontainer-features/goreg:1
```

The provided GitHub Action will also publish a "metadata" package with just the namespace, eg: `ghcr.io/Eagle-Konbu/devcontainer-features`.  This contains information useful for tools aiding in Feature discovery.

`Eagle-Konbu/devcontainer-features` is the feature collection namespace.

### Marking Feature Public

Note that by default, GHCR packages are marked as `private`.  To stay within the free tier, Features need to be marked as `public`.

This can be done by navigating to the Feature's "package settings" page in GHCR, and setting the visibility to 'public`.  The URL may look something like:

```
https://github.com/users/<owner>/packages/container/<repo>%2F<featureName>/settings
```

<img width="669" alt="image" src="https://user-images.githubusercontent.com/23246594/185244705-232cf86a-bd05-43cb-9c25-07b45b3f4b04.png">

### Adding Features to the Index

If you'd like your Features to appear in our [public index](https://containers.dev/features) so that other community members can find them, you can do the following:

* Go to [github.com/devcontainers/devcontainers.github.io](https://github.com/devcontainers/devcontainers.github.io)
     * This is the GitHub repo backing the [containers.dev](https://containers.dev/) spec site
* Open a PR to modify the [collection-index.yml](https://github.com/devcontainers/devcontainers.github.io/blob/gh-pages/_data/collection-index.yml) file

This index is from where [supporting tools](https://containers.dev/supporting) like [VS Code Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) and [GitHub Codespaces](https://github.com/features/codespaces) surface Features for their dev container creation UI.

#### Using private Features in Codespaces

For any Features hosted in GHCR that are kept private, the `GITHUB_TOKEN` access token in your environment will need to have `package:read` and `contents:read` for the associated repository.

Many implementing tools use a broadly scoped access token and will work automatically.  GitHub Codespaces uses repo-scoped tokens, and therefore you'll need to add the permissions in `devcontainer.json`

An example `devcontainer.json` can be found below.

```jsonc
{
    "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
    "features": {
     "ghcr.io/Eagle-Konbu/devcontainer-features/goreg:1": {
            "version": "latest"
        }
    },
    "customizations": {
        "codespaces": {
            "repositories": {
                "Eagle-Konbu/devcontainer-features": {
                    "permissions": {
                        "packages": "read",
                        "contents": "read"
                    }
                }
            }
        }
    }
}
```
